{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport Animated from \"react-native-reanimated\";\nimport { State } from \"react-native-gesture-handler\";\nimport { snapPoint } from \"./Animations\";\nvar Clock = Animated.Clock,\n    Value = Animated.Value,\n    event = Animated.event,\n    add = Animated.add,\n    block = Animated.block,\n    cond = Animated.cond,\n    divide = Animated.divide,\n    eq = Animated.eq,\n    multiply = Animated.multiply,\n    set = Animated.set,\n    stopClock = Animated.stopClock,\n    and = Animated.and,\n    not = Animated.not,\n    clockRunning = Animated.clockRunning,\n    startClock = Animated.startClock,\n    neq = Animated.neq,\n    call = Animated.call,\n    reDecay = Animated.decay,\n    reSpring = Animated.spring;\nexport var withOffset = function withOffset(value, state) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Value(0);\n  return cond(eq(state, State.END), [set(offset, add(offset, value)), offset], add(offset, value));\n};\nexport var withSpring = function withSpring(props) {\n  var _offset$props = _objectSpread({\n    offset: new Value(0)\n  }, props),\n      value = _offset$props.value,\n      velocity = _offset$props.velocity,\n      state = _offset$props.state,\n      snapPoints = _offset$props.snapPoints,\n      offset = _offset$props.offset,\n      springConfig = _offset$props.config,\n      onSnap = _offset$props.onSnap;\n\n  var clock = new Clock();\n  var springState = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: new Value(0),\n    time: new Value(0)\n  };\n\n  var config = _objectSpread({\n    toValue: new Value(0),\n    damping: 6,\n    mass: 1,\n    stiffness: 64,\n    overshootClamping: false,\n    restSpeedThreshold: 0.01,\n    restDisplacementThreshold: 0.01\n  }, springConfig);\n\n  var gestureAndAnimationIsOver = new Value(1);\n  var isSpringInterrupted = and(eq(state, State.BEGAN), clockRunning(clock));\n  var finishSpring = [set(offset, springState.position), stopClock(clock), set(gestureAndAnimationIsOver, 1)];\n  var snap = onSnap ? [cond(clockRunning(clock), call([springState.position], onSnap))] : [];\n  return block([cond(isSpringInterrupted, finishSpring), cond(gestureAndAnimationIsOver, set(springState.position, offset)), cond(neq(state, State.END), [set(gestureAndAnimationIsOver, 0), set(springState.finished, 0), set(springState.position, add(offset, value))]), cond(and(eq(state, State.END), not(gestureAndAnimationIsOver)), [cond(and(not(clockRunning(clock)), not(springState.finished)), [set(springState.velocity, velocity), set(springState.time, 0), set(config.toValue, snapPoint(springState.position, velocity, snapPoints)), startClock(clock)]), reSpring(clock, springState, config), cond(springState.finished, [].concat(snap, finishSpring))]), springState.position]);\n};\nexport var withDecay = function withDecay(config) {\n  var _offset$deceleration$ = _objectSpread({\n    offset: new Value(0),\n    deceleration: 0.998\n  }, config),\n      value = _offset$deceleration$.value,\n      velocity = _offset$deceleration$.velocity,\n      state = _offset$deceleration$.state,\n      offset = _offset$deceleration$.offset,\n      deceleration = _offset$deceleration$.deceleration;\n\n  var clock = new Clock();\n  var decayState = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: new Value(0),\n    time: new Value(0)\n  };\n  var isDecayInterrupted = and(eq(state, State.BEGAN), clockRunning(clock));\n  var finishDecay = [set(offset, decayState.position), stopClock(clock)];\n  return block([cond(isDecayInterrupted, finishDecay), cond(neq(state, State.END), [set(decayState.finished, 0), set(decayState.position, add(offset, value))]), cond(eq(state, State.END), [cond(and(not(clockRunning(clock)), not(decayState.finished)), [set(decayState.velocity, velocity), set(decayState.time, 0), startClock(clock)]), reDecay(clock, decayState, {\n    deceleration: deceleration\n  }), cond(decayState.finished, finishDecay)]), decayState.position]);\n};\nexport var preserveMultiplicativeOffset = function preserveMultiplicativeOffset(value, state) {\n  var previous = new Animated.Value(1);\n  var offset = new Animated.Value(1);\n  return block([cond(eq(state, State.BEGAN), [set(previous, 1)], [set(offset, multiply(offset, divide(value, previous))), set(previous, value)]), offset]);\n};\nexport var onScroll = function onScroll(contentOffset) {\n  return event([{\n    nativeEvent: {\n      contentOffset: contentOffset\n    }\n  }]);\n};\nexport var onGestureEvent = function onGestureEvent(nativeEvent) {\n  var gestureEvent = event([{\n    nativeEvent: nativeEvent\n  }]);\n  return {\n    onHandlerStateChange: gestureEvent,\n    onGestureEvent: gestureEvent\n  };\n};\nexport var panGestureHandler = function panGestureHandler() {\n  var x = new Value(0);\n  var translationX = new Value(0);\n  var velocityX = new Value(0);\n  var y = new Value(0);\n  var translationY = new Value(0);\n  var velocityY = new Value(0);\n  var state = new Value(State.UNDETERMINED);\n  var gestureHandler = onGestureEvent({\n    x: x,\n    translationX: translationX,\n    velocityX: velocityX,\n    y: y,\n    translationY: translationY,\n    velocityY: velocityY,\n    state: state\n  });\n  return {\n    x: x,\n    translationX: translationX,\n    velocityX: velocityX,\n    y: y,\n    translationY: translationY,\n    velocityY: velocityY,\n    state: state,\n    gestureHandler: gestureHandler\n  };\n};\nexport var horizontalPanGestureHandler = function horizontalPanGestureHandler() {\n  var x = new Value(0);\n  var translationX = new Value(0);\n  var velocityX = new Value(0);\n  var state = new Value(State.UNDETERMINED);\n  var gestureHandler = onGestureEvent({\n    translationX: translationX,\n    velocityX: velocityX,\n    state: state\n  });\n  return {\n    x: x,\n    translationX: translationX,\n    state: state,\n    velocityX: velocityX,\n    gestureHandler: gestureHandler\n  };\n};\nexport var verticalPanGestureHandler = function verticalPanGestureHandler() {\n  var y = new Value(0);\n  var translationY = new Value(0);\n  var velocityY = new Value(0);\n  var state = new Value(State.UNDETERMINED);\n  var gestureHandler = onGestureEvent({\n    y: y,\n    translationY: translationY,\n    velocityY: velocityY,\n    state: state\n  });\n  return {\n    y: y,\n    translationY: translationY,\n    state: state,\n    velocityY: velocityY,\n    gestureHandler: gestureHandler\n  };\n};","map":{"version":3,"sources":["Gesture.ts"],"names":["Clock","Value","event","add","block","cond","divide","eq","multiply","set","stopClock","and","not","clockRunning","startClock","neq","call","decay","reDecay","spring","reSpring","Animated","withOffset","offset","State","withSpring","value","velocity","state","snapPoints","springConfig","onSnap","clock","springState","finished","position","time","config","toValue","damping","mass","stiffness","overshootClamping","restSpeedThreshold","restDisplacementThreshold","gestureAndAnimationIsOver","isSpringInterrupted","finishSpring","snap","snapPoint","withDecay","deceleration","decayState","isDecayInterrupted","finishDecay","preserveMultiplicativeOffset","previous","onScroll","nativeEvent","contentOffset","onGestureEvent","gestureEvent","onHandlerStateChange","panGestureHandler","x","translationX","velocityX","y","translationY","velocityY","gestureHandler","horizontalPanGestureHandler","verticalPanGestureHandler"],"mappings":"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","sourcesContent":["import Animated from \"react-native-reanimated\";\nimport {\n  FlingGestureHandlerEventExtra,\n  ForceTouchGestureHandlerEventExtra,\n  GestureHandlerStateChangeNativeEvent,\n  LongPressGestureHandlerEventExtra,\n  PanGestureHandlerEventExtra,\n  PinchGestureHandlerEventExtra,\n  RotationGestureHandlerEventExtra,\n  State,\n  TapGestureHandlerEventExtra\n} from \"react-native-gesture-handler\";\n\nimport { snapPoint } from \"./Animations\";\n\nconst {\n  Clock,\n  Value,\n  event,\n  add,\n  block,\n  cond,\n  divide,\n  eq,\n  multiply,\n  set,\n  stopClock,\n  and,\n  not,\n  clockRunning,\n  startClock,\n  neq,\n  call,\n  decay: reDecay,\n  spring: reSpring\n} = Animated;\n\nexport const withOffset = (\n  value: Animated.Node<number>,\n  state: Animated.Value<State>,\n  offset: Animated.Value<number> = new Value(0)\n) =>\n  cond(\n    eq(state, State.END),\n    [set(offset, add(offset, value)), offset],\n    add(offset, value)\n  );\n\ninterface PrivateSpringConfig extends Animated.SpringConfig {\n  toValue: Animated.Value<number>;\n}\n\ntype SpringConfig = Omit<Animated.SpringConfig, \"toValue\">;\n\nexport interface WithSpringParams {\n  value: Animated.Adaptable<number>;\n  velocity: Animated.Adaptable<number>;\n  state: Animated.Value<State>;\n  snapPoints: Animated.Adaptable<number>[];\n  offset?: Animated.Value<number>;\n  config?: SpringConfig;\n  onSnap?: (value: readonly number[]) => void;\n}\n\nexport const withSpring = (props: WithSpringParams) => {\n  const {\n    value,\n    velocity,\n    state,\n    snapPoints,\n    offset,\n    config: springConfig,\n    onSnap\n  } = {\n    offset: new Value(0),\n    ...props\n  };\n  const clock = new Clock();\n  const springState: Animated.SpringState = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: new Value(0),\n    time: new Value(0)\n  };\n\n  const config: PrivateSpringConfig = {\n    toValue: new Value(0),\n    damping: 6,\n    mass: 1,\n    stiffness: 64,\n    overshootClamping: false,\n    restSpeedThreshold: 0.01,\n    restDisplacementThreshold: 0.01,\n    ...springConfig\n  };\n\n  const gestureAndAnimationIsOver = new Value(1);\n  const isSpringInterrupted = and(eq(state, State.BEGAN), clockRunning(clock));\n  const finishSpring = [\n    set(offset, springState.position),\n    stopClock(clock),\n    set(gestureAndAnimationIsOver, 1)\n  ];\n  const snap = onSnap\n    ? [cond(clockRunning(clock), call([springState.position], onSnap))]\n    : [];\n  return block([\n    cond(isSpringInterrupted, finishSpring),\n    cond(gestureAndAnimationIsOver, set(springState.position, offset)),\n    cond(neq(state, State.END), [\n      set(gestureAndAnimationIsOver, 0),\n      set(springState.finished, 0),\n      set(springState.position, add(offset, value))\n    ]),\n    cond(and(eq(state, State.END), not(gestureAndAnimationIsOver)), [\n      cond(and(not(clockRunning(clock)), not(springState.finished)), [\n        set(springState.velocity, velocity),\n        set(springState.time, 0),\n        set(\n          config.toValue,\n          snapPoint(springState.position, velocity, snapPoints)\n        ),\n        startClock(clock)\n      ]),\n      reSpring(clock, springState, config),\n      cond(springState.finished, [...snap, ...finishSpring])\n    ]),\n    springState.position\n  ]);\n};\n\ninterface WithDecayParams {\n  value: Animated.Adaptable<number>;\n  velocity: Animated.Adaptable<number>;\n  state: Animated.Value<State>;\n  offset?: Animated.Value<number>;\n  deceleration?: number;\n}\n\nexport const withDecay = (config: WithDecayParams) => {\n  const { value, velocity, state, offset, deceleration } = {\n    offset: new Value(0),\n    deceleration: 0.998,\n    ...config\n  };\n  const clock = new Clock();\n  const decayState = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: new Value(0),\n    time: new Value(0)\n  };\n\n  const isDecayInterrupted = and(eq(state, State.BEGAN), clockRunning(clock));\n  const finishDecay = [set(offset, decayState.position), stopClock(clock)];\n\n  return block([\n    cond(isDecayInterrupted, finishDecay),\n    cond(neq(state, State.END), [\n      set(decayState.finished, 0),\n      set(decayState.position, add(offset, value))\n    ]),\n    cond(eq(state, State.END), [\n      cond(and(not(clockRunning(clock)), not(decayState.finished)), [\n        set(decayState.velocity, velocity),\n        set(decayState.time, 0),\n        startClock(clock)\n      ]),\n      reDecay(clock, decayState, { deceleration }),\n      cond(decayState.finished, finishDecay)\n    ]),\n    decayState.position\n  ]);\n};\n\nexport const preserveMultiplicativeOffset = (\n  value: Animated.Adaptable<number>,\n  state: Animated.Adaptable<number>\n) => {\n  const previous = new Animated.Value(1);\n  const offset = new Animated.Value(1);\n\n  return block([\n    cond(\n      eq(state, State.BEGAN),\n      [set(previous, 1)],\n      [\n        set(offset, multiply(offset, divide(value, previous))),\n        set(previous, value)\n      ]\n    ),\n    offset\n  ]);\n};\n\nexport const onScroll = (contentOffset: {\n  x?: Animated.Node<number>;\n  y?: Animated.Node<number>;\n}) =>\n  event([\n    {\n      nativeEvent: {\n        contentOffset\n      }\n    }\n  ]);\n\ntype NativeEvent = GestureHandlerStateChangeNativeEvent &\n  (\n    | PanGestureHandlerEventExtra\n    | TapGestureHandlerEventExtra\n    | LongPressGestureHandlerEventExtra\n    | RotationGestureHandlerEventExtra\n    | FlingGestureHandlerEventExtra\n    | PinchGestureHandlerEventExtra\n    | ForceTouchGestureHandlerEventExtra\n  );\n\ntype Adaptable<T> = { [P in keyof T]: Animated.Adaptable<T[P]> };\n\nexport const onGestureEvent = (\n  nativeEvent: Partial<Adaptable<NativeEvent>>\n) => {\n  const gestureEvent = event([{ nativeEvent }]);\n  return {\n    onHandlerStateChange: gestureEvent,\n    onGestureEvent: gestureEvent\n  };\n};\n\nexport const panGestureHandler = () => {\n  const x = new Value(0);\n  const translationX = new Value(0);\n  const velocityX = new Value(0);\n  const y = new Value(0);\n  const translationY = new Value(0);\n  const velocityY = new Value(0);\n  const state = new Value(State.UNDETERMINED);\n  const gestureHandler = onGestureEvent({\n    x,\n    translationX,\n    velocityX,\n    y,\n    translationY,\n    velocityY,\n    state\n  });\n  return {\n    x,\n    translationX,\n    velocityX,\n    y,\n    translationY,\n    velocityY,\n    state,\n    gestureHandler\n  };\n};\n\nexport const horizontalPanGestureHandler = () => {\n  const x = new Value(0);\n  const translationX = new Value(0);\n  const velocityX = new Value(0);\n  const state = new Value(State.UNDETERMINED);\n  const gestureHandler = onGestureEvent({\n    translationX,\n    velocityX,\n    state\n  });\n  return {\n    x,\n    translationX,\n    state,\n    velocityX,\n    gestureHandler\n  };\n};\n\nexport const verticalPanGestureHandler = () => {\n  const y = new Value(0);\n  const translationY = new Value(0);\n  const velocityY = new Value(0);\n  const state = new Value(State.UNDETERMINED);\n  const gestureHandler = onGestureEvent({\n    y,\n    translationY,\n    velocityY,\n    state\n  });\n  return {\n    y,\n    translationY,\n    state,\n    velocityY,\n    gestureHandler\n  };\n};\n"]},"metadata":{},"sourceType":"module"}